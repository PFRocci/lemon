#! /usr/bin/env python

# Copyright (c) 2012 Victor Terron. All rights reserved.
# Institute of Astrophysics of Andalusia, IAA-CSIC
#
# This file is part of LEMON.
#
# LEMON is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import collections
import copy
import json
import lxml.etree
import operator

# LEMON modules
import methods
import passband

def validate_dtd(path):
    """ Validate an XML file against a DTD.

    The method validates an Extensible Markup Language (XML) against a Document
    Type Definition (DTD) referenced by the document, raising the appropriate
    exception if an error is encountered, and doing nothing otherwise.

    """

    dtd_parser = lxml.etree.XMLParser(dtd_validation = True)
    lxml.etree.parse(path, dtd_parser)

def setup_header(xml_content, dtd):
    """ Add to an XML file the creation time and the Document Type Definition.

    Receive a string with the contents of an XML file and insert after the
    header (1) a comment with the current time, in UTC, labeled as the creation
    date of the file, and (2) the Document Type Definition (DTD). Because of
    (1), this method is expected to be called right before the XML file is
    written to disk.

    """

    lines = xml_content.split('\n')
    comment = "<!-- File generated by LEMON on %s -->" % methods.utctime()
    lines.insert(1, comment)
    lines = lines[:2] + dtd + lines[2:]
    return '\n'.join(lines)


typename = 'CandidateAnnuli'
field_names = "aperture, annulus, dannulus, stdev"
class CandidateAnnuli(collections.namedtuple(typename, field_names)):
    """ Encapsulate the quality of a set of photometric parameters.

    How do we determine how good a set of parameters for aperture photometry
    is? In order to compare them, we need to identify the most constant stars
    (or, by extension, any other astronomical object) in the field and compute
    their light curves. The better the aperture, annulus and dannulus that we
    use are, the lower the standard deviation of the resulting curves.

    This class simply encapsulates these four values, mapping the parameters
    for aperture photometry (aperture, annulus and dannulus) to the standard
    deviation of the light curves of the most constant astronomical objects.

    Fields:
    aperture - the aperture radius, in pixels.
    annulus - the inner radius of the sky annulus, in pixels.
    dannulus - the width of the sky annulus, in pixels.
    stdev - the median, arithmetic mean or a similar statistical measure of the
            standard deviation of the light curves of the astronomical objects
            when photometry is done using these aperture, annulus and dannulus
            values.

    """

    XML_DTD = [
    "",
    "<!DOCTYPE annuli [",
    "<!ELEMENT annuli (band*)>",
    "",
    "<!ELEMENT band (candidate*)>",
    "<!ATTLIST band name     CDATA #REQUIRED>",
    "<!ATTLIST band aperture CDATA #REQUIRED>",
    "<!ATTLIST band annulus  CDATA #REQUIRED>",
    "<!ATTLIST band dannulus CDATA #REQUIRED>",
    "<!ATTLIST band stdev    CDATA #REQUIRED>",
    "",
    "<!ELEMENT candidate EMPTY>",
    "<!ATTLIST candidate aperture CDATA #REQUIRED>",
    "<!ATTLIST candidate annulus  CDATA #REQUIRED>",
    "<!ATTLIST candidate dannulus CDATA #REQUIRED>",
    "<!ATTLIST candidate stdev    CDATA #REQUIRED>",
    "]>",
    ""]

    @classmethod
    def dump(cls, annuli, path):
        """ Save a series of CadidateAnnuli objects to a JSON file.

        Serialize 'annuli' to a JSON file. It must be a dictionary which maps
        each photometric filter (a Passband object) to a sequence of the
        corresponding CandidateAnnuli objects -- i.e., the different aperture
        photometric parameters that were evaluated for that filter. The output
        file will be mercilessly overwritten if it already exists.

        """

        # Being a subclass of tuple, JSON serializes namedtuples as lists. We
        # need to convert them to ordered dictionaries (namedtuple._asdict())
        # first, so that the field names are not lost in the serialization.
        data = copy.deepcopy(annuli)
        for values in data.itervalues():
            for index in xrange(len(values)):
                values[index] = values[index]._asdict()

        # Use strings, not Passband objects, as keys
        for pfilter in data.iterkeys():
            data[str(pfilter)] = data.pop(pfilter)

        with open(path, 'wt') as fd:
            json.dump(data, fd, indent=2)

    @staticmethod
    def xml_load(xml_path):
        """ Load a series of CandidateAnnuli instances from an XML file.

        This method reverses the functionality of xml_dump(), reading an XML
        file and returning a dictionary which maps each photometric filter to a
        list of the CandidateAnnuli instances that were saved to it. These
        lists are sorted in increasing order by the standard deviation of the
        CandidateAnnuli, so that the one with the lowest standard deviation
        (and therefore the optimal for aperture photometric) is returned first.

        The XML files generated by LEMON are always standalone documents,
        meaning that the Document Type Definitions (DTD), defining the document
        structure with a list of legal elements, are also included. If the XML
        file cannot be validated, the appropiate exception will be raised.

        xml_path - the path to the XML file to which the CandidateAnnuli
                   instances were saved and from which they will be now loaded.

        """

        with open(xml_path, 'r') as _: pass
        root = lxml.etree.parse(xml_path).getroot()

        # For each passband, the optimal aperture and sky annuli are stored as
        # attributes of the <band> entity, so that the optimal parameters for
        # aperture photometry can be quickly identified in the XML file. When
        # the candidate annuli are de-serialized, however, these attributes can
        # be ignored, as the best parameters are also listed as <candidate>
        # entities for each photometric passband.

        annuli = collections.defaultdict(list)
        for band in root:
            pfilter = passband.Passband(band.get('name'))
            attrs = 'aperture', 'annulus', 'dannulus', 'stdev'
            for candidate in band:
                cand = CandidateAnnuli(*[float(candidate.get(x)) for x in attrs])
                annuli[pfilter].append(cand)

        # Sort the CandidateAnnuli for each filter by their standard deviation
        for candidates in annuli.itervalues():
            candidates.sort(key = operator.attrgetter('stdev'))

        return annuli
