#! /usr/bin/env python

# Copyright (c) 2012 Victor Terron. All rights reserved.
# Institute of Astrophysics of Andalusia, IAA-CSIC
#
# This file is part of LEMON.
#
# LEMON is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import collections
import lxml.etree
import operator

# LEMON modules
import methods
import passband

def validate_dtd(path):
    """ Validate an XML file against a DTD.

    The method validates an Extensible Markup Language (XML) against a Document
    Type Definition (DTD) referenced by the document, raising the appropriate
    exception if an error is encountered, and doing nothing otherwise.

    """

    dtd_parser = lxml.etree.XMLParser(dtd_validation = True)
    lxml.etree.parse(path, dtd_parser)

def setup_header(xml_content, dtd):
    """ Add to an XML file the creation time and the Document Type Definition.

    Receive a string with the contents of an XML file and insert after the
    header (1) a comment with the current time, in UTC, labeled as the creation
    date of the file, and (2) the Document Type Definition (DTD). Because of
    (1), this method is expected to be called right before the XML file is
    written to disk.

    """

    lines = xml_content.split('\n')
    comment = "<!-- File generated by LEMON on %s -->" % methods.utctime()
    lines.insert(1, comment)
    lines = lines[:2] + dtd + lines[2:]
    return '\n'.join(lines)


typename = 'CandidateAnnuli'
field_names = "aperture, annulus, dannulus, stdev"
class CandidateAnnuli(collections.namedtuple(typename, field_names)):
    """ Encapsulates the quality of a set of photometric parameters.

    How do we determine how 'good' a set of aperture, annulus and dannulus
    values are for photometry? What we do is to look at the median (or even the
    arithmetic mean, for this matter both approaches are statistically sound)
    standard deviation of the light curves of the most constant stars. It
    follows that the better (i.e., most appropiate for the images being
    reduced) the parameters, the lower this standard deviation will be.

    This class simply encapsulates these four values. You may think of it as a
    surjective function (as two different sets of parameters may result in the
    same values) which links a three-element tuple with the parameters used for
    photometry (aperture, annulus, dannulus) to the standard deviation of the
    light curves of the most constant stars.

    """

    XML_DTD = [
    "",
    "<!DOCTYPE annuli [",
    "<!ELEMENT annuli (band*)>",
    "",
    "<!ELEMENT band (candidate*)>",
    "<!ATTLIST band name     CDATA #REQUIRED>",
    "<!ATTLIST band aperture CDATA #REQUIRED>",
    "<!ATTLIST band annulus  CDATA #REQUIRED>",
    "<!ATTLIST band dannulus CDATA #REQUIRED>",
    "<!ATTLIST band stdev    CDATA #REQUIRED>",
    "",
    "<!ELEMENT candidate EMPTY>",
    "<!ATTLIST candidate aperture CDATA #REQUIRED>",
    "<!ATTLIST candidate annulus  CDATA #REQUIRED>",
    "<!ATTLIST candidate dannulus CDATA #REQUIRED>",
    "<!ATTLIST candidate stdev    CDATA #REQUIRED>",
    "]>",
    ""]


    def __init__(self, aperture, annulus, dannulus, stdev):
        """ Instantiation method.

        aperture - the aperture radius, in pixels.
        annulus - the inner radius of the sky annulus, in pixels.
        dannulus - the width of the sky annulus, in pixels.
        stdev - the median, arithmetic mean or a similar statistical measure
                of the standard deviation of the light curves of the evaluated
                stars when photometry is done using these aperture, annulus
                and dannulus values.

        """

        self.aperture = aperture
        self.annulus  = annulus
        self.dannulus = dannulus
        self.stdev    = stdev

    def __eq__(self, other):
        return self.aperture == other.aperture and \
               self.annulus == other.annulus and \
               self.dannulus == other.dannulus and \
               self.stdev == other.stdev

    def __ne__(self, other):
        return not self == other

    def __repr__(self):
        """ The unambiguous string representation of a CandidateAnnuli """
        return "%s(%r, %r, %r, %r)" % (self.__class__.__name__, self.aperture,
                                       self.annulus, self.dannulus, self.stdev)

    @classmethod
    def xml_dump(cls, xml_path, annuli, encoding = 'utf-8'):
        """ Save multiple CadidateAnnuli instances to an XML file.

        This method dumps to a file the XML representation of a dictionary
        which maps each photometric filter to a list of the CandidateInstances
        that for it were evaluated. This offers a functionality similar to that
        of the pickle module, with the additional advantages of being
        human-readable, easily understood and parseable virtually everywhere.

        The generated XML file is a standalone document, which means that the
        Document Type Definitions (DTD), defining the document structure with a
        list of legal elements, is also included. This information is used by
        the XML processor in order to validate the code.

        xml_path - the path to which to save the XML file. Any existing file
                   will be mercilessly overwritten without warning.
        annuli - a dictionary mapping each photometric filter to a list of
                 CandidateInstances, encapsulating the quality of a set of
                 photometric parameters.
        encoding - the character encoding system to use.

        """

        root = lxml.etree.Element('annuli')

        for pfilter in sorted(annuli.iterkeys()):

            # Identify the candidate parameters for which the standard
            # deviation of the curves of the most constant stars is minimal.
            best = min(annuli[pfilter], key = operator.attrgetter('stdev'))

            # Three attributes (i.e., values within the start-tag) identify the
            # optimal photometric parameters for this photometric filters. In
            # this manner, the aperture and sky annuli that are more adequate
            # for aperture photometry can be easily identified in the XML file.
            # The median or arithmetic mean of the standard deviation of the
            # light curves of the constant stars when photometry was done in
            # order to evaluate these parameters is also stored for debugging
            # purposes.

            kwargs = {'name' : str(pfilter),
                      'aperture' : '%.5f' % best.aperture,
                      'annulus' : '%.5f' % best.annulus,
                      'dannulus' : '%.5f' % best.dannulus,
                      'stdev' : '%.8f' % best.stdev}
            band_element = lxml.etree.Element('band', **kwargs)

            # Although most of the time only the optimal photometric parameters
            # will be of interest, it is also worth saving all the aperture and
            # sky annuli that were evaluated and the median or mean stardard
            # deviation that resulted from using them. Note that the optimal
            # parameters are included here again, as the purpose of this
            # listing is to provide a compendium of all the photometric
            # parameters that were taken into consideration. The photometric
            # parameters will be listed sorted on two keys: the aperture
            # annulus itself (primary) and the sky annulus (secondary).

            annuli[pfilter].sort(key = operator.attrgetter('annulus', 'aperture'))
            for candidate in annuli[pfilter]:
                kwargs = {'aperture' : '%.5f' % candidate.aperture,
                          'annulus' : '%.5f' % candidate.annulus,
                          'dannulus' : '%.5f' % candidate.dannulus,
                          'stdev' : '%.8f' % candidate.stdev}
                cand_element = lxml.etree.Element('candidate', **kwargs)
                band_element.append(cand_element)

            root.append(band_element)

        kwargs = {'encoding' : encoding, 'xml_declaration': True,
                  'pretty_print' : True, 'standalone' : True}
        xml_content = lxml.etree.tostring(root, **kwargs)
        xml_content = setup_header(xml_content, cls.XML_DTD)

        with open(xml_path, 'wt') as fd:
            fd.write(xml_content)
        validate_dtd(xml_path)


    @staticmethod
    def xml_load(xml_path):
        """ Load a series of CandidateAnnuli instances from an XML file.

        This method reverses the functionality of xml_dump(), reading an XML
        file and returning a dictionary which maps each photometric filter to a
        list of the CandidateAnnuli instances that were saved to it. These
        lists are sorted in increasing order by the standard deviation of the
        CandidateAnnuli, so that the one with the lowest standard deviation
        (and therefore the optimal for aperture photometric) is returned first.

        The XML files generated by LEMON are always standalone documents,
        meaning that the Document Type Definitions (DTD), defining the document
        structure with a list of legal elements, are also included. If the XML
        file cannot be validated, the appropiate exception will be raised.

        xml_path - the path to the XML file to which the CandidateAnnuli
                   instances were saved and from which they will be now loaded.

        """

        with open(xml_path, 'r') as _: pass
        root = lxml.etree.parse(xml_path).getroot()

        # For each passband, the optimal aperture and sky annuli are stored as
        # attributes of the <band> entity, so that the optimal parameters for
        # aperture photometry can be quickly identified in the XML file. When
        # the candidate annuli are de-serialized, however, these attributes can
        # be ignored, as the best parameters are also listed as <candidate>
        # entities for each photometric passband.

        annuli = collections.defaultdict(list)
        for band in root:
            pfilter = passband.Passband(band.get('name'))
            attrs = 'aperture', 'annulus', 'dannulus', 'stdev'
            for candidate in band:
                cand = CandidateAnnuli(*[float(candidate.get(x)) for x in attrs])
                annuli[pfilter].append(cand)

        # Sort the CandidateAnnuli for each filter by their standard deviation
        for candidates in annuli.itervalues():
            candidates.sort(key = operator.attrgetter('stdev'))

        return annuli
